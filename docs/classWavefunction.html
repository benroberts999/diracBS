<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ampsci: Wavefunction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ampsci
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classWavefunction-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Wavefunction</div>  </div>
</div><!--header-->
<div class="contents">

<p>Stores <a class="el" href="classWavefunction.html" title="Stores Wavefunction (set of core+valence orbitals, grid etc.) ">Wavefunction</a> (set of core+valence orbitals, grid etc.)  
 <a href="classWavefunction.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Wavefunction_8hpp_source.html">Wavefunction.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3532575173529a54b8579f3873e4a052"><td class="memItemLeft" align="right" valign="top"><a id="a3532575173529a54b8579f3873e4a052"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Wavefunction</b> (const <a class="el" href="structGridParameters.html">GridParameters</a> &amp;gridparams, const <a class="el" href="structNuclear_1_1Parameters.html">Nuclear::Parameters</a> &amp;nuc_params, double var_alpha=1.0)</td></tr>
<tr class="separator:a3532575173529a54b8579f3873e4a052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80b3b7c39d7cfb02634162c2001b2d0"><td class="memItemLeft" align="right" valign="top"><a id="ac80b3b7c39d7cfb02634162c2001b2d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ac80b3b7c39d7cfb02634162c2001b2d0">Wavefunction</a> (const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;wf)</td></tr>
<tr class="memdesc:ac80b3b7c39d7cfb02634162c2001b2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined copy-constructor. Note: Does not copy <a class="el" href="namespaceHF.html" title="Functions and classes for Hartree-Fock. ">HF</a> or Sigma. <br /></td></tr>
<tr class="separator:ac80b3b7c39d7cfb02634162c2001b2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8796ce3a1b76c1992d4b9b09d4a04ff"><td class="memItemLeft" align="right" valign="top"><a id="ac8796ce3a1b76c1992d4b9b09d4a04ff"></a>
<a class="el" href="classWavefunction.html">Wavefunction</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;)=delete</td></tr>
<tr class="separator:ac8796ce3a1b76c1992d4b9b09d4a04ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323a18d94cb2242a666a584be6ca08bc"><td class="memItemLeft" align="right" valign="top"><a id="a323a18d94cb2242a666a584be6ca08bc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Znuc</b> () const</td></tr>
<tr class="separator:a323a18d94cb2242a666a584be6ca08bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a36b73812ebae2e76f55d475149fa9e"><td class="memItemLeft" align="right" valign="top"><a id="a6a36b73812ebae2e76f55d475149fa9e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Anuc</b> () const</td></tr>
<tr class="separator:a6a36b73812ebae2e76f55d475149fa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1b6e923c2fb1ad11336cb8a672bc90"><td class="memItemLeft" align="right" valign="top"><a id="a5f1b6e923c2fb1ad11336cb8a672bc90"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a5f1b6e923c2fb1ad11336cb8a672bc90">Nnuc</a> () const</td></tr>
<tr class="memdesc:a5f1b6e923c2fb1ad11336cb8a672bc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of neutrons, A-Z. <br /></td></tr>
<tr class="separator:a5f1b6e923c2fb1ad11336cb8a672bc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcbf541d7102af9c59139aa8ba5288c"><td class="memItemLeft" align="right" valign="top"><a id="addcbf541d7102af9c59139aa8ba5288c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#addcbf541d7102af9c59139aa8ba5288c">Ncore</a> () const</td></tr>
<tr class="memdesc:addcbf541d7102af9c59139aa8ba5288c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of electrons in the core. <br /></td></tr>
<tr class="separator:addcbf541d7102af9c59139aa8ba5288c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23419504a8487d1a26a4db49cfa87b84"><td class="memItemLeft" align="right" valign="top"><a id="a23419504a8487d1a26a4db49cfa87b84"></a>
const <a class="el" href="structNuclear_1_1Parameters.html">Nuclear::Parameters</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_nuclearParameters</b> () const</td></tr>
<tr class="separator:a23419504a8487d1a26a4db49cfa87b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736ad360b2a3ea96a65397a08aeffe85"><td class="memItemLeft" align="right" valign="top"><a id="a736ad360b2a3ea96a65397a08aeffe85"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>get_rrms</b> () const</td></tr>
<tr class="separator:a736ad360b2a3ea96a65397a08aeffe85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d78460329b281438a3831c297cc3198"><td class="memItemLeft" align="right" valign="top"><a id="a6d78460329b281438a3831c297cc3198"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>exclude_exchangeQ</b> () const</td></tr>
<tr class="separator:a6d78460329b281438a3831c297cc3198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c3fda343f20bd25d7083dd77216ae2"><td class="memItemLeft" align="right" valign="top"><a id="a14c3fda343f20bd25d7083dd77216ae2"></a>
const <a class="el" href="classMBPT_1_1CorrelationPotential.html">MBPT::CorrelationPotential</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a14c3fda343f20bd25d7083dd77216ae2">getSigma</a> () const</td></tr>
<tr class="memdesc:a14c3fda343f20bd25d7083dd77216ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns ptr to (const) Correlation Potential, Sigma. <br /></td></tr>
<tr class="separator:a14c3fda343f20bd25d7083dd77216ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d02f0eb51f8ea97b3aa367afa60035d"><td class="memItemLeft" align="right" valign="top"><a id="a0d02f0eb51f8ea97b3aa367afa60035d"></a>
const <a class="el" href="classHF_1_1HartreeFock.html">HF::HartreeFock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a0d02f0eb51f8ea97b3aa367afa60035d">getHF</a> () const</td></tr>
<tr class="memdesc:a0d02f0eb51f8ea97b3aa367afa60035d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns ptr to (const) Hartree Fock (class) <br /></td></tr>
<tr class="separator:a0d02f0eb51f8ea97b3aa367afa60035d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab672b0491827eeb68f136cbea761a086"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ab672b0491827eeb68f136cbea761a086">getState</a> (int n, int k, bool *is_valence=nullptr) const</td></tr>
<tr class="separator:ab672b0491827eeb68f136cbea761a086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2a48e73e1019c79b026e10850e54f7"><td class="memItemLeft" align="right" valign="top"><a id="a6d2a48e73e1019c79b026e10850e54f7"></a>
const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>firstCoreState</b> (int k) const</td></tr>
<tr class="separator:a6d2a48e73e1019c79b026e10850e54f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6d4072e01657a226377f12706be0e4"><td class="memItemLeft" align="right" valign="top"><a id="afe6d4072e01657a226377f12706be0e4"></a>
const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>firstValenceState</b> (int k) const</td></tr>
<tr class="separator:afe6d4072e01657a226377f12706be0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f3e32b0b49ce99dbfb7dbfba8cc7a1"><td class="memItemLeft" align="right" valign="top"><a id="a36f3e32b0b49ce99dbfb7dbfba8cc7a1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a36f3e32b0b49ce99dbfb7dbfba8cc7a1">energy_gap</a> () const</td></tr>
<tr class="memdesc:a36f3e32b0b49ce99dbfb7dbfba8cc7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Energy gap between lowest valence + highest core state. <br /></td></tr>
<tr class="separator:a36f3e32b0b49ce99dbfb7dbfba8cc7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae1dac145d79df6ed23600b0588da1e"><td class="memItemLeft" align="right" valign="top"><a id="a4ae1dac145d79df6ed23600b0588da1e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a4ae1dac145d79df6ed23600b0588da1e">coreConfiguration</a> () const</td></tr>
<tr class="memdesc:a4ae1dac145d79df6ed23600b0588da1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns full core configuration. <br /></td></tr>
<tr class="separator:a4ae1dac145d79df6ed23600b0588da1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7206fa0868e18ef7e2b6e13c0d969d"><td class="memItemLeft" align="right" valign="top"><a id="a7e7206fa0868e18ef7e2b6e13c0d969d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a7e7206fa0868e18ef7e2b6e13c0d969d">coreConfiguration_nice</a> () const</td></tr>
<tr class="memdesc:a7e7206fa0868e18ef7e2b6e13c0d969d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns core configuration, in nice output notation. <br /></td></tr>
<tr class="separator:a7e7206fa0868e18ef7e2b6e13c0d969d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6714bfc943e32a1a2a23993ed89160d"><td class="memItemLeft" align="right" valign="top"><a id="ad6714bfc943e32a1a2a23993ed89160d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ad6714bfc943e32a1a2a23993ed89160d">nuclearParams</a> () const</td></tr>
<tr class="memdesc:ad6714bfc943e32a1a2a23993ed89160d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs screen-friendly nuclear parameters. <br /></td></tr>
<tr class="separator:ad6714bfc943e32a1a2a23993ed89160d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd94450e44598ec2605a36b468317ba"><td class="memItemLeft" align="right" valign="top"><a id="aafd94450e44598ec2605a36b468317ba"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#aafd94450e44598ec2605a36b468317ba">atom</a> () const</td></tr>
<tr class="memdesc:aafd94450e44598ec2605a36b468317ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">String of atom info (e.g., "Cs, Z=55, A=133") <br /></td></tr>
<tr class="separator:aafd94450e44598ec2605a36b468317ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfcac1486b376cd770c170f3ed96b41"><td class="memItemLeft" align="right" valign="top"><a id="a6bfcac1486b376cd770c170f3ed96b41"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a6bfcac1486b376cd770c170f3ed96b41">atomicSymbol</a> () const</td></tr>
<tr class="memdesc:a6bfcac1486b376cd770c170f3ed96b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">e.g., "Cs" <br /></td></tr>
<tr class="separator:a6bfcac1486b376cd770c170f3ed96b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e72272c10fd5b60add76bc8e57e1d71"><td class="memItemLeft" align="right" valign="top"><a id="a4e72272c10fd5b60add76bc8e57e1d71"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a4e72272c10fd5b60add76bc8e57e1d71">Zion</a> () const</td></tr>
<tr class="memdesc:a4e72272c10fd5b60add76bc8e57e1d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effective charge (for core) = Z-N_core. <br /></td></tr>
<tr class="separator:a4e72272c10fd5b60add76bc8e57e1d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407659d98aa3f8c87035ab786cb1ed81"><td class="memItemLeft" align="right" valign="top"><a id="a407659d98aa3f8c87035ab786cb1ed81"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a407659d98aa3f8c87035ab786cb1ed81">identity</a> () const</td></tr>
<tr class="memdesc:a407659d98aa3f8c87035ab786cb1ed81"><td class="mdescLeft">&#160;</td><td class="mdescRight">E.g., Cs in V^N-1, gives Cs-i. <br /></td></tr>
<tr class="separator:a407659d98aa3f8c87035ab786cb1ed81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec274d6030d1ab0ade862b0c71c680b"><td class="memItemLeft" align="right" valign="top"><a id="afec274d6030d1ab0ade862b0c71c680b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#afec274d6030d1ab0ade862b0c71c680b">printCore</a> (bool sorted=true) const</td></tr>
<tr class="memdesc:afec274d6030d1ab0ade862b0c71c680b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints table of core orbitals + energies etc. Optionally sorted by energy. <br /></td></tr>
<tr class="separator:afec274d6030d1ab0ade862b0c71c680b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4be3780df83537a6242849a526a87d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#afd4be3780df83537a6242849a526a87d">printValence</a> (bool sorted=true, const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;tmp_orbitals={}) const</td></tr>
<tr class="memdesc:afd4be3780df83537a6242849a526a87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints table of valence orbitals + energies etc. Optionally sorted by energy.  <a href="#afd4be3780df83537a6242849a526a87d">More...</a><br /></td></tr>
<tr class="separator:afd4be3780df83537a6242849a526a87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd57736cbb14a2407135316f62b67a3"><td class="memItemLeft" align="right" valign="top"><a id="a3cd57736cbb14a2407135316f62b67a3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a3cd57736cbb14a2407135316f62b67a3">printBasis</a> (const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;the_basis, bool sorted=false) const</td></tr>
<tr class="memdesc:a3cd57736cbb14a2407135316f62b67a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints table of Basis/Spectrum orbitals, compares to <a class="el" href="namespaceHF.html" title="Functions and classes for Hartree-Fock. ">HF</a> orbitals. <br /></td></tr>
<tr class="separator:a3cd57736cbb14a2407135316f62b67a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab31789fb358324bf35331455688b6cb"><td class="memItemLeft" align="right" valign="top"><a id="aab31789fb358324bf35331455688b6cb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInCore</b> (int n, int k) const</td></tr>
<tr class="separator:aab31789fb358324bf35331455688b6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc58b95259bb712e40f69ecec6653ee3"><td class="memItemLeft" align="right" valign="top"><a id="afc58b95259bb712e40f69ecec6653ee3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInValence</b> (int n, int k) const</td></tr>
<tr class="separator:afc58b95259bb712e40f69ecec6653ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73dcc0493d6c286717d668762d0aa7c"><td class="memItemLeft" align="right" valign="top"><a id="aa73dcc0493d6c286717d668762d0aa7c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#aa73dcc0493d6c286717d668762d0aa7c">maxCore_n</a> (int ka_in=0) const</td></tr>
<tr class="memdesc:aa73dcc0493d6c286717d668762d0aa7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Largest n for core states (optional: for given kappa, otherwise overall) <br /></td></tr>
<tr class="separator:aa73dcc0493d6c286717d668762d0aa7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce2da0d8a4545f8700a75c13004309f"><td class="memItemLeft" align="right" valign="top"><a id="a0ce2da0d8a4545f8700a75c13004309f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a0ce2da0d8a4545f8700a75c13004309f">maxCore_l</a> () const</td></tr>
<tr class="memdesc:a0ce2da0d8a4545f8700a75c13004309f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Largest l for core states. <br /></td></tr>
<tr class="separator:a0ce2da0d8a4545f8700a75c13004309f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e359ee6a36453ec2dc2823b106bd689"><td class="memItemLeft" align="right" valign="top"><a id="a0e359ee6a36453ec2dc2823b106bd689"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a0e359ee6a36453ec2dc2823b106bd689">coreDensity</a> () const</td></tr>
<tr class="memdesc:a0e359ee6a36453ec2dc2823b106bd689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates rho(r) = sum_c psi^2(r) for core states, c={n,k,m}. <br /></td></tr>
<tr class="separator:a0e359ee6a36453ec2dc2823b106bd689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd8536bc40762a0b9aa6be39dacf658"><td class="memItemLeft" align="right" valign="top"><a id="adfd8536bc40762a0b9aa6be39dacf658"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#adfd8536bc40762a0b9aa6be39dacf658">hartreeFockCore</a> (const std::string &amp;method, const double x_Breit, const std::string &amp;in_core, double eps_HF=0)</td></tr>
<tr class="memdesc:adfd8536bc40762a0b9aa6be39dacf658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs hartree-Fock procedure for core: note: poplulates core. <br /></td></tr>
<tr class="separator:adfd8536bc40762a0b9aa6be39dacf658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee52168498b9d13f4c081d1c76df9579"><td class="memItemLeft" align="right" valign="top"><a id="aee52168498b9d13f4c081d1c76df9579"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#aee52168498b9d13f4c081d1c76df9579">coreEnergyHF</a> () const</td></tr>
<tr class="memdesc:aee52168498b9d13f4c081d1c76df9579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates <a class="el" href="namespaceHF.html" title="Functions and classes for Hartree-Fock. ">HF</a> core energy (doesn't include magnetic QED?) <br /></td></tr>
<tr class="separator:aee52168498b9d13f4c081d1c76df9579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba83051a902184b8c889990710584daf"><td class="memItemLeft" align="right" valign="top"><a id="aba83051a902184b8c889990710584daf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#aba83051a902184b8c889990710584daf">hartreeFockValence</a> (const std::string &amp;in_valence_str, const bool print=true)</td></tr>
<tr class="memdesc:aba83051a902184b8c889990710584daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs hartree-Fock procedure for valence: note: poplulates valnece. <br /></td></tr>
<tr class="separator:aba83051a902184b8c889990710584daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97b219b6d39a6b86989ac014bcdbeeb"><td class="memItemLeft" align="right" valign="top"><a id="ac97b219b6d39a6b86989ac014bcdbeeb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ac97b219b6d39a6b86989ac014bcdbeeb">localValence</a> (const std::string &amp;in_valence_str, bool list_each=false)</td></tr>
<tr class="memdesc:ac97b219b6d39a6b86989ac014bcdbeeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves new local valence (e.g., Kohn-Sham): note: poplulates valence. <br /></td></tr>
<tr class="separator:ac97b219b6d39a6b86989ac014bcdbeeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb1d340794e7d2a2afaa2e9184ff4c6"><td class="memItemLeft" align="right" valign="top"><a id="addb1d340794e7d2a2afaa2e9184ff4c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#addb1d340794e7d2a2afaa2e9184ff4c6">hartreeFockBrueckner</a> (const bool print=true)</td></tr>
<tr class="memdesc:addb1d340794e7d2a2afaa2e9184ff4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms Bruckner valence orbitals: (H_hf + Sigma)|nk&gt; = e|nk&gt;. <br /></td></tr>
<tr class="separator:addb1d340794e7d2a2afaa2e9184ff4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c8fd9c5768cf18ddb2427f57b8d1b1"><td class="memItemLeft" align="right" valign="top"><a id="a09c8fd9c5768cf18ddb2427f57b8d1b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a09c8fd9c5768cf18ddb2427f57b8d1b1">fitSigma_hfBrueckner</a> (const std::string &amp;valence_list, const std::vector&lt; double &gt; &amp;fit_energies)</td></tr>
<tr class="memdesc:a09c8fd9c5768cf18ddb2427f57b8d1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">First, fits Sigma to energies, then forms fitted Brueckner orbitals. <br /></td></tr>
<tr class="separator:a09c8fd9c5768cf18ddb2427f57b8d1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06dc0029ecd5bf449db3dc85782687ed"><td class="memItemLeft" align="right" valign="top"><a id="a06dc0029ecd5bf449db3dc85782687ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a06dc0029ecd5bf449db3dc85782687ed">SOEnergyShift</a> ()</td></tr>
<tr class="memdesc:a06dc0029ecd5bf449db3dc85782687ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second-order <a class="el" href="namespaceMBPT.html" title="Many-body perturbation theory. ">MBPT</a> energy shifts, calculates + prints. <br /></td></tr>
<tr class="separator:a06dc0029ecd5bf449db3dc85782687ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081140df1355d07d709b4b57edda4058"><td class="memItemLeft" align="right" valign="top"><a id="a081140df1355d07d709b4b57edda4058"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a081140df1355d07d709b4b57edda4058">radiativePotential</a> (double x_simple, double x_Ueh, double x_SEe_h, double x_SEe_l, double x_SEm, double rcut, double scale_rN, const std::vector&lt; double &gt; &amp;x_spd)</td></tr>
<tr class="memdesc:a081140df1355d07d709b4b57edda4058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates radiative potential. Stores in vnuc, and Hmag. <br /></td></tr>
<tr class="separator:a081140df1355d07d709b4b57edda4058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b4000c0b43b5437b9cb7acae829c90"><td class="memItemLeft" align="right" valign="top"><a id="a10b4000c0b43b5437b9cb7acae829c90"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a10b4000c0b43b5437b9cb7acae829c90">formBasis</a> (const SplineBasis::Parameters &amp;params)</td></tr>
<tr class="memdesc:a10b4000c0b43b5437b9cb7acae829c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates + populates basis [see BSplineBasis]. <br /></td></tr>
<tr class="separator:a10b4000c0b43b5437b9cb7acae829c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854d9e30f51b7978eb01d140bba65893"><td class="memItemLeft" align="right" valign="top"><a id="a854d9e30f51b7978eb01d140bba65893"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a854d9e30f51b7978eb01d140bba65893">formSpectrum</a> (const SplineBasis::Parameters &amp;params)</td></tr>
<tr class="memdesc:a854d9e30f51b7978eb01d140bba65893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates + populates Spectrum [see BSplineBasis]. <br /></td></tr>
<tr class="separator:a854d9e30f51b7978eb01d140bba65893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1110b9c6e99020286de6c83d9f12272b"><td class="memItemLeft" align="right" valign="top"><a id="a1110b9c6e99020286de6c83d9f12272b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a1110b9c6e99020286de6c83d9f12272b">formSigma</a> (const int nmin_core=1, const bool form_matrix=true, const double r0=1.0e-4, const double rmax=30.0, const int stride=4, const bool include_G=false, const std::vector&lt; double &gt; &amp;lambdas={}, const std::vector&lt; double &gt; &amp;fk={}, const std::string &amp;fname=&quot;&quot;, const bool FeynmanQ=false, const bool ScreeningQ=false, const bool holeParticleQ=false, const int lmax=6, const bool GreenBasis=false, const bool PolBasis=false, const double omre=-0.2, double w0=0.01, double wratio=1.5)</td></tr>
<tr class="memdesc:a1110b9c6e99020286de6c83d9f12272b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms + stores correlation potential Sigma. <br /></td></tr>
<tr class="separator:a1110b9c6e99020286de6c83d9f12272b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e19a81c27c14374bb244aef7ff70f4"><td class="memItemLeft" align="right" valign="top"><a id="ae7e19a81c27c14374bb244aef7ff70f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ae7e19a81c27c14374bb244aef7ff70f4">solveDirac</a> (<a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;psi, double e_a, const std::vector&lt; double &gt; &amp;vex, int log_eps=0) const</td></tr>
<tr class="memdesc:ae7e19a81c27c14374bb244aef7ff70f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves Dirac bound state problem, with optional 'extra' potential log_eps is log_10(convergence_target). <br /></td></tr>
<tr class="separator:ae7e19a81c27c14374bb244aef7ff70f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e4f4b64ca295fb181898a5fda218d9"><td class="memItemLeft" align="right" valign="top"><a id="a80e4f4b64ca295fb181898a5fda218d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>solveDirac</b> (<a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;psi, double e_a=0, int log_eps=0) const</td></tr>
<tr class="separator:a80e4f4b64ca295fb181898a5fda218d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82c0566346307be004cfa20184bce77"><td class="memItemLeft" align="right" valign="top"><a id="ab82c0566346307be004cfa20184bce77"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ab82c0566346307be004cfa20184bce77">solveInitialCore</a> (const std::string &amp;str_core_in, int log_dele_or=0)</td></tr>
<tr class="memdesc:ab82c0566346307be004cfa20184bce77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates core orbitals accorind to given core string (+solves) <br /></td></tr>
<tr class="separator:ab82c0566346307be004cfa20184bce77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59de760c3ac17db4c6ac778f148a25d"><td class="memItemLeft" align="right" valign="top"><a id="ae59de760c3ac17db4c6ac778f148a25d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ae59de760c3ac17db4c6ac778f148a25d">solveNewValence</a> (int n, int k, double en_a=0, int log_dele_or=0)</td></tr>
<tr class="memdesc:ae59de760c3ac17db4c6ac778f148a25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds new valence orbtial (+solves using vdir) <br /></td></tr>
<tr class="separator:ae59de760c3ac17db4c6ac778f148a25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298b0e062106fc74f5d932fc04c5959c"><td class="memItemLeft" align="right" valign="top"><a id="a298b0e062106fc74f5d932fc04c5959c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a298b0e062106fc74f5d932fc04c5959c">enGuessCore</a> (int n, int l) const</td></tr>
<tr class="memdesc:a298b0e062106fc74f5d932fc04c5959c"><td class="mdescLeft">&#160;</td><td class="mdescRight">energy guess for a core state with n,l; quite rough, but good enough <br /></td></tr>
<tr class="separator:a298b0e062106fc74f5d932fc04c5959c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173cb9f26b8f12abe4481a3c775697b8"><td class="memItemLeft" align="right" valign="top"><a id="a173cb9f26b8f12abe4481a3c775697b8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a173cb9f26b8f12abe4481a3c775697b8">enGuessVal</a> (int n, int ka) const</td></tr>
<tr class="memdesc:a173cb9f26b8f12abe4481a3c775697b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">energy guess for a valence state with n,l <br /></td></tr>
<tr class="separator:a173cb9f26b8f12abe4481a3c775697b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221666d6a4e2da0d65e3c25cc6f6e0c9"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a221666d6a4e2da0d65e3c25cc6f6e0c9">lminmax_core_range</a> (int l, double eps=0.0) const</td></tr>
<tr class="memdesc:a221666d6a4e2da0d65e3c25cc6f6e0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns [min,max] r values for which the core density (given l) is larger than cutoff (= eps*max_value)  <a href="#a221666d6a4e2da0d65e3c25cc6f6e0c9">More...</a><br /></td></tr>
<tr class="separator:a221666d6a4e2da0d65e3c25cc6f6e0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d782608856812b81742c96dc1611d1"><td class="memItemLeft" align="right" valign="top"><a id="ae0d782608856812b81742c96dc1611d1"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ae0d782608856812b81742c96dc1611d1">get_Vlocal</a> (int l=0) const</td></tr>
<tr class="memdesc:ae0d782608856812b81742c96dc1611d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local potential, e.g., Vl = Vnuc + Vdir + Vrad_el(l) - can be l-dependent. <br /></td></tr>
<tr class="separator:ae0d782608856812b81742c96dc1611d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c500c39c8ed2e6febe8066ffcaf4b18"><td class="memItemLeft" align="right" valign="top"><a id="a6c500c39c8ed2e6febe8066ffcaf4b18"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_Hmag</b> (int l=0) const</td></tr>
<tr class="separator:a6c500c39c8ed2e6febe8066ffcaf4b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a246fe3a9ade2de69d291b9a85d320819"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a246fe3a9ade2de69d291b9a85d320819">orthonormaliseOrbitals</a> (std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;in_orbs, int num_its=1)</td></tr>
<tr class="separator:a246fe3a9ade2de69d291b9a85d320819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452b9f8d6b08205f4b241389fc953c78"><td class="memItemLeft" align="right" valign="top"><a id="a452b9f8d6b08205f4b241389fc953c78"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a452b9f8d6b08205f4b241389fc953c78">orthonormaliseWrt</a> (<a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;psi_v, const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;in_orbs)</td></tr>
<tr class="memdesc:a452b9f8d6b08205f4b241389fc953c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">(exactly) OrthoNormalises psi_v against of any orbitals. <br /></td></tr>
<tr class="separator:a452b9f8d6b08205f4b241389fc953c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada80d191cc539d3914f6ad531c793d5e"><td class="memItemLeft" align="right" valign="top"><a id="ada80d191cc539d3914f6ad531c793d5e"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ada80d191cc539d3914f6ad531c793d5e">orthogonaliseWrt</a> (<a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;psi_v, const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;in_orbs)</td></tr>
<tr class="memdesc:ada80d191cc539d3914f6ad531c793d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(exactly) OrthoGonalises psi_v against of any orbitals (no Norm). <br /></td></tr>
<tr class="separator:ada80d191cc539d3914f6ad531c793d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a819d5591db7e1345e5e871d1fd3d62f6"><td class="memItemLeft" align="right" valign="top"><a id="a819d5591db7e1345e5e871d1fd3d62f6"></a>
std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a819d5591db7e1345e5e871d1fd3d62f6">core</a> {}</td></tr>
<tr class="memdesc:a819d5591db7e1345e5e871d1fd3d62f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Frozen" Core orbitals <br /></td></tr>
<tr class="separator:a819d5591db7e1345e5e871d1fd3d62f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0123a0eb76e7b6a55381bea604e74a51"><td class="memItemLeft" align="right" valign="top"><a id="a0123a0eb76e7b6a55381bea604e74a51"></a>
std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a0123a0eb76e7b6a55381bea604e74a51">valence</a> {}</td></tr>
<tr class="memdesc:a0123a0eb76e7b6a55381bea604e74a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valence (single-particle) orbitals. <br /></td></tr>
<tr class="separator:a0123a0eb76e7b6a55381bea604e74a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fa0df03a87345a65d5ded908510ce9"><td class="memItemLeft" align="right" valign="top"><a id="a31fa0df03a87345a65d5ded908510ce9"></a>
std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a31fa0df03a87345a65d5ded908510ce9">basis</a> {}</td></tr>
<tr class="memdesc:a31fa0df03a87345a65d5ded908510ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basis, daigonalised over <a class="el" href="namespaceHF.html" title="Functions and classes for Hartree-Fock. ">HF</a> core. Used for <a class="el" href="namespaceMBPT.html" title="Many-body perturbation theory. ">MBPT</a>. <br /></td></tr>
<tr class="separator:a31fa0df03a87345a65d5ded908510ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62844704b8a4defbd1977d227b3c46d"><td class="memItemLeft" align="right" valign="top"><a id="ae62844704b8a4defbd1977d227b3c46d"></a>
std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ae62844704b8a4defbd1977d227b3c46d">spectrum</a> {}</td></tr>
<tr class="memdesc:ae62844704b8a4defbd1977d227b3c46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sprectrum: like basis, but includes Sigma (correlations). <br /></td></tr>
<tr class="separator:ae62844704b8a4defbd1977d227b3c46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144c32bcbe5aba32e2c5bd0771c89b08"><td class="memItemLeft" align="right" valign="top"><a id="a144c32bcbe5aba32e2c5bd0771c89b08"></a>
std::shared_ptr&lt; const <a class="el" href="classGrid.html">Grid</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a144c32bcbe5aba32e2c5bd0771c89b08">rgrid</a></td></tr>
<tr class="memdesc:a144c32bcbe5aba32e2c5bd0771c89b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radial grid. <br /></td></tr>
<tr class="separator:a144c32bcbe5aba32e2c5bd0771c89b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ed885c1683b5d048d3727bb27f07a9"><td class="memItemLeft" align="right" valign="top"><a id="a07ed885c1683b5d048d3727bb27f07a9"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a07ed885c1683b5d048d3727bb27f07a9">alpha</a></td></tr>
<tr class="memdesc:a07ed885c1683b5d048d3727bb27f07a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal value for alpha (alpha = var_alpha * alpha_0, alpha_0=~1/137) <br /></td></tr>
<tr class="separator:a07ed885c1683b5d048d3727bb27f07a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab067a5f8d2001474d609215d74732d9c"><td class="memItemLeft" align="right" valign="top"><a id="ab067a5f8d2001474d609215d74732d9c"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ab067a5f8d2001474d609215d74732d9c">vnuc</a> {}</td></tr>
<tr class="memdesc:ab067a5f8d2001474d609215d74732d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceNuclear.html" title="Data and useful functions. Radii all in Fermi (fm, e-15m) ">Nuclear</a> potential. <br /></td></tr>
<tr class="separator:ab067a5f8d2001474d609215d74732d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea877d1c943977e5ca769dc48281029"><td class="memItemLeft" align="right" valign="top"><a id="a8ea877d1c943977e5ca769dc48281029"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a8ea877d1c943977e5ca769dc48281029">vdir</a> {}</td></tr>
<tr class="memdesc:a8ea877d1c943977e5ca769dc48281029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct/local part of the electron potential. <br /></td></tr>
<tr class="separator:a8ea877d1c943977e5ca769dc48281029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4093a4d3c9b46968aa7f51ffa34736"><td class="memItemLeft" align="right" valign="top"><a id="abc4093a4d3c9b46968aa7f51ffa34736"></a>
<a class="el" href="classRadiativePotential_1_1Vrad.html">RadiativePotential::Vrad</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#abc4093a4d3c9b46968aa7f51ffa34736">vrad</a> {}</td></tr>
<tr class="memdesc:abc4093a4d3c9b46968aa7f51ffa34736"><td class="mdescLeft">&#160;</td><td class="mdescRight">QED radiative potential. <br /></td></tr>
<tr class="separator:abc4093a4d3c9b46968aa7f51ffa34736"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stores <a class="el" href="classWavefunction.html" title="Stores Wavefunction (set of core+valence orbitals, grid etc.) ">Wavefunction</a> (set of core+valence orbitals, grid etc.) </p>
<dl class="section user"><dt>Construction:</dt><dd><ul>
<li>Set of <a class="el" href="structGridParameters.html" title="Parmaters used to create Grid. ">GridParameters</a> [see Maths/Grid]</li>
<li>Set of <a class="el" href="structNuclear_1_1Parameters.html" title="Stores set of nuclear parameters. ">Nuclear::Parameters</a> [see Physics/NuclearPotentials]</li>
<li>var_alpha = <img class="formulaInl" alt="$\lambda$" src="form_53.png"/>, <img class="formulaInl" alt="$\alpha = \lambda\alpha_0$" src="form_11.png"/> </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab672b0491827eeb68f136cbea761a086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab672b0491827eeb68f136cbea761a086">&#9670;&nbsp;</a></span>getState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a>* Wavefunction::getState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_valence</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds requested state; returns nullptr if not found</p>
<p>is_valence is optional out-parameter; tells you where orb was found </p>

</div>
</div>
<a id="a221666d6a4e2da0d65e3c25cc6f6e0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221666d6a4e2da0d65e3c25cc6f6e0c9">&#9670;&nbsp;</a></span>lminmax_core_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;double, double&gt; Wavefunction::lminmax_core_range </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns [min,max] r values for which the core density (given l) is larger than cutoff (= eps*max_value) </p>
<p>Returns the r values (au) for which the value of rho = |psi^2|(r) drops below cutoff. Sum goes over all m for given l. Cut-off defined as eps*max, where max is maximum value for rho(r). Set l&lt;0 to get for all l (entire core) </p>

</div>
</div>
<a id="a246fe3a9ade2de69d291b9a85d320819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246fe3a9ade2de69d291b9a85d320819">&#9670;&nbsp;</a></span>orthonormaliseOrbitals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Wavefunction::orthonormaliseOrbitals </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_orbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_its</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(approximately) OrthoNormalises a set of any orbitals.</p>
<p>Note: only updates orbs, not energies </p>

</div>
</div>
<a id="afd4be3780df83537a6242849a526a87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4be3780df83537a6242849a526a87d">&#9670;&nbsp;</a></span>printValence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wavefunction::printValence </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp_orbitals</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints table of valence orbitals + energies etc. Optionally sorted by energy. </p>
<p>Can optionally give it any list of orbitals to print </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Wavefunction/<a class="el" href="Wavefunction_8hpp_source.html">Wavefunction.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
