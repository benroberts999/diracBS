<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ampsci: Input options for: ampsci</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ampsci
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Input options for: ampsci </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This outlines/describes the input options/usage for ampsci. For a description of the physics, see: <a href="https://benroberts999.github.io/ampsci/ampsci.pdf">ampsci.pdf</a></p>
<ul>
<li>The <b>ampsci</b> program should be run as:<ul>
<li>_./ampsci inputFile.in_</li>
<li>"inputFile.in" is a plain-text input file, that contains all input options (if no input file is given, program looks for the default one, named "ampsci.in")</li>
</ul>
</li>
<li>First, the program reads in the main input options from the four main input "blocks" (Atom, Nucleus, HartreeFock, and <a class="el" href="classGrid.html" title="Holds grid, including type + Jacobian (dr/du) ">Grid</a>). It will use these to generate wavefunction/Hartree-Fock etc. Then, any number of optional "modules" are run using the above-calculated wavefunctions (e.g., these might calculate matrix elements, run tests etc.). The input blocks and options can be given in any order</li>
<li>In general, the input file will have the following format:</li>
</ul>
<div class="fragment"><div class="line">Atom { &lt;input_options&gt; }</div><div class="line">Nucleus { &lt;input_options&gt; }</div><div class="line"><a class="code" href="classGrid.html">Grid</a> { &lt;input_options&gt; }</div><div class="line">HartreeFock { &lt;input_options&gt; }</div><div class="line"><span class="comment">//Optional modules:</span></div><div class="line">Module::firstModule { &lt;input_options&gt; }</div><div class="line">Module::secondModule { &lt;input_options&gt; }</div></div><!-- fragment --><ul>
<li>Most options have a default; these may be left blank, explicitly set to 'default', or removed entirely.</li>
<li>The curly-braces denote the start/end of each block. <em>Don't</em> use any other curly-braces (nested curly-braces are not allowed)</li>
<li>Uses c++ style comments. Any commented-out line will not be read. White-space is ignored.</li>
<li>For example, the following inputs are all equivalent</li>
</ul>
<div class="fragment"><div class="line">Atom {</div><div class="line">  Z = Cs;</div><div class="line">  A;</div><div class="line">}</div><div class="line">Atom {</div><div class="line">  Z = Cs;</div><div class="line"><span class="comment">//  A;</span></div><div class="line">}</div><div class="line">Atom { Z = Cs; }</div><div class="line">Atom { Z = 55; A = 133; }</div><div class="line">Atom{Z=Cs;A=<span class="keywordflow">default</span>;}</div></div><!-- fragment --><ul>
<li>All available inputs for each input block are listed below<ul>
<li>Inputs are taken in as either text, boolean (true/false), integers, or real numbers, or a "sub-block"</li>
<li>These will be denoted by [t], [b], [i], [r], [sub-block]</li>
<li>A sub-block is a bracketed list of sub-options, e.g.<ul>
<li>options = [a=1; b=2;];</li>
</ul>
</li>
</ul>
</li>
<li>Program will <em>usually</em> warn you if an incorrect option is given, and print all the available options to the screen &ndash; you can use this fact to get the code to print all the available options for each block.</li>
</ul>
<hr/>
 <h1>Each input block:</h1>
<h2>Atom</h2>
<div class="fragment"><div class="line">Atom {</div><div class="line">  Z = Cs;    <span class="comment">//[t/i] required</span></div><div class="line">  A;         <span class="comment">//[i] Will look-up default value if default</span></div><div class="line">  varAlpha2; <span class="comment">//[r] default = 1</span></div><div class="line">}</div></div><!-- fragment --><ul>
<li>Z: Which atom. Can enter as symbol (e.g., Z = Cs;) or integer (e.g., Z = 55;). Required (no default)</li>
<li>A: nuclear mass number. Leave blank to look up default value</li>
<li>varAlpha2: Scaling factor for alpha^2 (c = 1/alpha in atomic units): alpha^2 = varAlpha2 * alpha_real^2.<ul>
<li>default=1. put a very small number to achieve non-relativistic limit (useful for tests)</li>
</ul>
</li>
</ul>
<p>## HartreeFock </p><div class="fragment"><div class="line">HartreeFock {</div><div class="line">  core;        <span class="comment">//[t] default = [] (no core)</span></div><div class="line">  valence;     <span class="comment">//[t] default = none</span></div><div class="line">  sortOutput;  <span class="comment">//[b] default = false</span></div><div class="line">  method;      <span class="comment">//[t] default = HartreeFock</span></div><div class="line">  Breit;       <span class="comment">//[r] default = 0.0</span></div><div class="line">  convergence; <span class="comment">//[r] default = 1.0e-12</span></div><div class="line">}</div></div><!-- fragment --><ul>
<li>core: Core configuration. Format: "[Atom],extra"<ul>
<li>'Extra' is comma-separated list of 'nLm' terms (eg: '1s2,2s2,2p6')</li>
<li>'[Atom]' is optional, can just list all configurations</li>
<li>'[Atom]' is usually a Noble gas, but can be any atom</li>
<li>Can also add negative values for occupations (m)</li>
<li>E.g. :<ul>
<li>Cs (V^N-1): '[Xe]'</li>
<li>Cs (V^N-1): '[Cs],6s-1' (equivalent to [Xe])</li>
<li>Au (V^N-1): '[Xe],4f14,5d10' or '[Hg],6s-2'</li>
<li>Tl (V^N-1): '[Xe],4f14,5d10,6s2' or '[Hg]'</li>
<li>I (V^N): '[Cd],5p5' or '[Xe],5p-1', or [I]</li>
<li>H-like: enter as: [] (or 1s0) &ndash; no electrons in core</li>
</ul>
</li>
</ul>
</li>
<li>valence: which valence states to calculate<ul>
<li>e.g., "7sp5df" will do s and p states up to n=7, and d and f up to n=5</li>
</ul>
</li>
<li>sortOutput: true or false. Sort output by energy.</li>
<li>method: which method to use. can be:<ul>
<li>HartreeFock(default), ApproxHF, Hartree, KohnSham</li>
<li>Note: for KohnSham: Should be V^N - i.e., include lowest valence state into core.<ul>
<li>e.g., for Cs: core=[Xe],6s1 (or 'core=[Cs]'); Then list each valence state in valence:</li>
<li>e.g., to solve valence 6s, 7s, and 6p, write valence="6s7s6p";</li>
</ul>
</li>
</ul>
</li>
<li>Breit: Include Breit into <a class="el" href="namespaceHF.html" title="Functions and classes for Hartree-Fock. ">HF</a> with given scale (0 means don't include)<ul>
<li>Note: Will go into spline basis, and RPA equations automatically</li>
</ul>
</li>
<li>convergence: level we try to converge to.</li>
</ul>
<p>## Nucleus </p><div class="fragment"><div class="line">Nucleus {</div><div class="line">  type;    <span class="comment">//[t] default = Fermi</span></div><div class="line">  rrms;    <span class="comment">//[r] will loop-up default value based on Z,A</span></div><div class="line">  <a class="code" href="namespacePhysConst.html#af3948ef083a64b0a3ff75aa6e8ddf8e9">c</a>;       <span class="comment">//[r] will loop-up default value based on Z,A</span></div><div class="line">  t;       <span class="comment">//[r] default = 2.3</span></div><div class="line">}</div></div><!-- fragment --><ul>
<li>rrms: nuclear root-mean-square charge radius (in femptometres = 10^-15m)</li>
<li>type: Which distribution to use for nucleus? Options are: Fermi (default), spherical, point</li>
<li>t: skin thickness [only used by Fermi distro]</li>
<li>c: half-density radius [only used by Fermi distro]<ul>
<li>nb: if rrms and c are given, c takes priority, and rrms is calculated from c (and t)</li>
</ul>
</li>
</ul>
<p>## <a class="el" href="classGrid.html" title="Holds grid, including type + Jacobian (dr/du) ">Grid</a> </p><div class="fragment"><div class="line"><a class="code" href="classGrid.html">Grid</a> {</div><div class="line">  r0;         <span class="comment">//[r] default = 1.0e-6</span></div><div class="line">  rmax;       <span class="comment">//[r] default = 120.0</span></div><div class="line">  num_points; <span class="comment">//[i] default = 1600</span></div><div class="line">  type;       <span class="comment">//[t] default = loglinear</span></div><div class="line">  b;          <span class="comment">//[r] default = rmax/3</span></div><div class="line">  fixed_du;   <span class="comment">//[r] default = -1.</span></div><div class="line">}</div></div><!-- fragment --><ul>
<li>r0: grid starting point (in atomic units)</li>
<li>rmax: Final grid point (in atomic units)</li>
<li>num_points: number of points in the grid</li>
<li>type: options are: loglinear (default), logarithmic, linear<ul>
<li>Note: 'linear' grid requires a <em>very</em> large number of points to work, and should essentially never be used.</li>
</ul>
</li>
<li>b: only used for loglinear grid; the grid is roughly logarithmic below this value, and linear after it. Default is 4.0 (atomic units). If b&lt;0 or b&gt;rmax, will revert to using a logarithmic grid</li>
<li>fixed_du: if fixed_du&gt;0.0, it will calculate num_points to fix du (step-size in uniform 'u' grid); will over-ride 'num_points' option.</li>
</ul>
<p>## dVpol (effective polarisation potential) </p><div class="fragment"><div class="line">dVpol {</div><div class="line">  a_eff;  <span class="comment">//[r] default = 0.0, typical ~1</span></div><div class="line">  r_cut;  <span class="comment">//[r] default = 1.0</span></div><div class="line">}</div><div class="line"><span class="comment">//nb: all of these are optional, hence entire block can be omitted</span></div></div><!-- fragment --><ul>
<li>Effective polarisation potential:</li>
<li>dV = -0.5 * a_eff / (r^4 + r_cut^4)</li>
<li>nb: Added to direct potential <em>after</em> <a class="el" href="namespaceHF.html" title="Functions and classes for Hartree-Fock. ">HF</a> for core, but <em>before</em> <a class="el" href="namespaceHF.html" title="Functions and classes for Hartree-Fock. ">HF</a> for valence</li>
</ul>
<p>## ExtraPotential (read from text file) </p><div class="fragment"><div class="line">ExtraPotential {</div><div class="line">  filename; <span class="comment">//[t] default = &quot;&quot;</span></div><div class="line">  factor;   <span class="comment">//[r] default = 0.0</span></div><div class="line">  beforeHF; <span class="comment">//[b] default = false</span></div><div class="line">}</div><div class="line"><span class="comment">//nb: all of these are optional, hence entire block can be omitted</span></div></div><!-- fragment --><ul>
<li>Reads in extra potential from text file (space separated: 'x y' format):</li>
<li>Interpolates these points onto the grid (but does NOT extrapolate, potential is assumed to be zero outside the given range)</li>
<li>Potential is multiplied by 'factor'</li>
<li>May be added before or after <a class="el" href="namespaceHF.html" title="Functions and classes for Hartree-Fock. ">HF</a> (if before: added to vnuc, if after: to vdir)</li>
</ul>
<p>## RadPot (Ginges/Flambaum QED Radiative Potential) </p><div class="fragment"><div class="line">RadPot {</div><div class="line">  RadPot;   <span class="comment">//[b] default = false, to include QED, set to true</span></div><div class="line">  Simple;   <span class="comment">//[r] default = 0.0 // Vrad = -Z^2 * alpha * exp(-r/alpha)</span></div><div class="line">  Ueh;      <span class="comment">//[r] default = 1.0 // Uehling (vac pol)</span></div><div class="line">  SE_h;     <span class="comment">//[r] default = 1.0 // high-f SE</span></div><div class="line">  SE_l;     <span class="comment">//[r] default = 1.0 // low-f SE</span></div><div class="line">  SE_m;     <span class="comment">//[r] default = 1.0 // Magnetic SE</span></div><div class="line">  rcut;     <span class="comment">//[r] default = 5.0</span></div><div class="line">  scale_rN; <span class="comment">//[r] default = 1.0</span></div><div class="line">  scale_l;  <span class="comment">//[r,r...] (List) default = 1.0</span></div><div class="line">  core_qed; <span class="comment">//[b] default = true</span></div><div class="line">}</div></div><!-- fragment --><ul>
<li>Adds QED radiative potential to Hamiltonian.</li>
<li>RadPot must be set to true to include QED</li>
<li>If full rad pot is used (Uehling+SE), will read write from file named Z.qed<ul>
<li>Rad pot depends only on Z. Note: scale_rN ignored if reading from file (will be whatever it was when file written; not saved)</li>
<li>scale_l and core_qed not written to .qed file; read from input each run</li>
</ul>
</li>
<li>Each factor is a scale; 0 means don't include. 1 means include full potential. Any positive number is valid.</li>
<li>rcut: Only calculates potential for r &lt; rcut [for speed; rcut in au]</li>
<li>scale_rN: finite nucleus effects: rN = rN * scale_rN (for testing only)</li>
<li>scale_l: Optional input: Scaling factors for the V_rad for each l state; for higher states, uses the last given input. Input as a list of real numbers. Best explained with examples:<ul>
<li>scale_l = 1; // include QED for all states</li>
<li>scale_l = 0,1,0; //include QED for p states only</li>
<li>scale_l = 0,1; //inlcude QED for p,d,f.. but not s states.</li>
<li>don't need to be 1 or 0, can be any real number.</li>
</ul>
</li>
<li>core_qed: if true, will include QED effects into core in Hartree-Fock (relaxation). If false, will include QED only for valence states</li>
</ul>
<h2>Basis (B-spline basis for <a class="el" href="namespaceMBPT.html" title="Many-body perturbation theory. ">MBPT</a>)</h2>
<ul>
<li>The 'basis' is used for summing over states in <a class="el" href="namespaceMBPT.html" title="Many-body perturbation theory. ">MBPT</a>. (A second 'basis', called spectrum, may be used for summation over states in other problems) <div class="fragment"><div class="line">Basis {</div><div class="line">  number;   <span class="comment">//[i] default = 0</span></div><div class="line">  order;    <span class="comment">//[i] default = 0</span></div><div class="line">  r0;       <span class="comment">//[r] default = 0</span></div><div class="line">  r0_eps;   <span class="comment">//[r] default = 0</span></div><div class="line">  rmax;     <span class="comment">//[r] default = 0</span></div><div class="line">  print;    <span class="comment">//[b] default = false</span></div><div class="line">  positron; <span class="comment">//[b] default = false</span></div><div class="line">  states;   <span class="comment">//[t] default = &quot;&quot;</span></div><div class="line">}</div></div><!-- fragment --></li>
<li>Constructs basis using <em>number</em> splines of order <em>order</em></li>
<li>on sub-grid (r0,rmax) [if zero, will use full grid]</li>
<li>r0_eps: Only calculate splines for r where relative core density is larger than r0_eps (updates r0 for each l). Typically ~1.0e-8. Set to zero to use r0.</li>
<li>If print = true, will print basis energies</li>
<li>positron: include negative energy states into basis</li>
<li>states: which basis states to store<ul>
<li>e.g., "7sp5df" will store s and p states up to n=7, and d and f up to n=5</li>
<li>spd will store <em>all</em> (number) states for l&lt;=2</li>
</ul>
</li>
</ul>
<h2>Correlations (Correlation potential, Sigma)</h2>
<ul>
<li>For including correlations. 'basis' must exist to calculate Sigma, but not to read Sigma in from file. <div class="fragment"><div class="line">Correlations {</div><div class="line">  io_file;        <span class="comment">//[b] default = true (or [t]; see below)</span></div><div class="line">  n_min_core;     <span class="comment">//[i] default = 1</span></div><div class="line">  energyShifts;   <span class="comment">//[b] default = false</span></div><div class="line">  Brueckner;      <span class="comment">//[b] default = false</span></div><div class="line">  lambda_k;       <span class="comment">//[r,r...] (list) default is blank.</span></div><div class="line">  fk;             <span class="comment">//[r,r...] (list) default is blank.</span></div><div class="line">  fitTo_cm;       <span class="comment">//[r,r...] (list) default is blank.</span></div><div class="line">  <span class="comment">// Following are &quot;sub-grid&quot; options:</span></div><div class="line">  stride;         <span class="comment">//[i] default chosen so there&#39;s ~150 pts in region [e-4,30]</span></div><div class="line">  rmin;           <span class="comment">//[i] 1.0e-4</span></div><div class="line">  rmax;           <span class="comment">//[i] 30.0</span></div><div class="line">}</div></div><!-- fragment --></li>
<li>Includes correlation corrections. note: splines must exist already</li>
<li>io_file: Read/write from/to file. Set to 'false' to calculate from scratch (and not write to file), true to read/write from/to default filename. Alternatively, put any text here to be a custom filename (e.g., io_file="new"; will read/write from/to new.Sigma &ndash; useful for tests). Grids must match exactly when reading in from a file.<ul>
<li>If reading Sigma in from file, basis doesn't need to exist</li>
</ul>
</li>
<li>n_min_core: minimum core n included in the Sigma calculation; lowest states often contribute little, so this speeds up the calculations</li>
<li>energyShifts: If true, will calculate the second-order energy shifts (from scratch, according to <a class="el" href="namespaceMBPT.html" title="Many-body perturbation theory. ">MBPT</a>) - compares to &lt;v|Sigma|v&gt; if it exists<ul>
<li>Note: Uses basis. If reading Sigma from disk, and no basis given, energy shifts will all be 0.0</li>
</ul>
</li>
<li>Brueckner: Construct Brueckner valence orbitals using correlation potential method (i.e., include correlations into wavefunctions and energies for valence states)</li>
<li>stride: Only calculates Sigma every nth point (Sigma is NxN matrix, so stride=4 leads to ~16x speed-up vs 1)</li>
<li>rmin/rmax: min/max points along radial <a class="el" href="classGrid.html" title="Holds grid, including type + Jacobian (dr/du) ">Grid</a> Sigma is calculated+stored.</li>
<li>lambda_k: Rescale Sigma -&gt; lambda*Sigma. One lambda for each kappa. If not given, assumed to be 1.<ul>
<li>Note: Lambda's are not written/read to file, so these must be given (if required) even when reading Sigma from disk</li>
</ul>
</li>
<li>fk: Effective screening factors; only used for 2nd-order Goldstone method<ul>
<li>Note: Included directly into Sigma</li>
<li>e.g., for Cs: fk = 0.72, 0.62, 0.83, 0.89, 0.94, 1.0;</li>
</ul>
</li>
<li>fitTo_cm: Provide list of energies (lowest valence states for each kappa); Sigma for each kappa will be automatically re-scaled to exactly reproduce these. Give as binding energies in inverse cm! It will print the lambda_k's that it calculated<ul>
<li>e.g., fitTo_cm = -31406.5, -20228.2, -19674.1; will fit for the lowest s &amp; p states for Cs</li>
<li>Will over-write lambda_k</li>
<li>-43487.11, -28583.45, -28583.11, -12204.03, -12203.99, -6856.91, -6856.91; // Li</li>
<li>-41449.45, -24493.28, -24476.08, -12276.56, -12276.61, -6862.53, -6862.53; // Na</li>
<li>-35009.81, -22024.63, -21966.92, -13472.83, -13475.13, -6881.96, -6881.96; // K</li>
<li>-33690.81, -21111.86, -20874.265, -14335.161, -14335.607, -6898.692, -6898.718; // Rb</li>
<li>-31406.468, -20228.200, -19674.161, -16907.211, -16809.625, -6934.241, -6934.422; // Cs</li>
<li>-80686.30, -60424.74, -58733.90, -75812.45, -75011.49, -32427.68, -32202.97; // Ba+</li>
<li>-32848.87, -20611.46, -18924.87, -16619.00, -16419.23; // Fr</li>
<li>-81842.5 -60491.2, -55633.6, -69758.2, -68099.5, -32854.6, -32570.4; // Ra+</li>
</ul>
</li>
</ul>
<h2>Spectrum (B-spline basis for <a class="el" href="namespaceMBPT.html" title="Many-body perturbation theory. ">MBPT</a>)</h2>
<ul>
<li>The 'Spectrum' is similar to basis, but also includes correlation corrections (if Sigma exists)</li>
<li>Useful, since we often need a small basis to compute <a class="el" href="namespaceMBPT.html" title="Many-body perturbation theory. ">MBPT</a> terms, but a large basis to complete other sum-over-states calculations. <div class="fragment"><div class="line">Spectrum {</div><div class="line">  <span class="comment">// exact same inputs as Basis{}</span></div><div class="line">}</div></div><!-- fragment --></li>
</ul>
<h2>Modules</h2>
<p>Each Modules block will be run in order. You can comment-out just the block name, and the block will be skipped.</p>
<h3><a class="el" href="namespaceModule.html#a55c4b7766fbc4c805ae6bd65bf9b8783" title="Calculates matrix elements of any tensor operator, with RPA. ">Module::matrixElements</a></h3>
<p><a class="el" href="namespaceModule.html" title="Modules are run using calculated atomic wavefunctions. ">Module</a> to calculate Matrix Elements. For matrixElements, there are some options that apply for any operator; and then there are some options specific to each operator; these operator-specific options are given as a [] bracketed list of options ("sub-block")</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceModule.html#a55c4b7766fbc4c805ae6bd65bf9b8783">Module::matrixElements</a> {</div><div class="line">  <span class="keyword">operator</span>;       <span class="comment">//[t] default = &quot;&quot;</span></div><div class="line">  options;        <span class="comment">//[sub-block], default = &quot;&quot;</span></div><div class="line">  printBoth;      <span class="comment">//[t] default = false</span></div><div class="line">  onlyDiagonal;   <span class="comment">//[t] default = false</span></div><div class="line">  radialIntegral; <span class="comment">//[b] default = false</span></div><div class="line">  rpa;            <span class="comment">//[b] default = true</span></div><div class="line">  rpa_diagram;    <span class="comment">//[b] default = false</span></div><div class="line">  omega;          <span class="comment">//[r] default = 0.0;  or [t] (&#39;each&#39;)</span></div><div class="line">  A_vertex;       <span class="comment">//[r] default = 0.0 - for QED vertex</span></div><div class="line">  b_vertex;       <span class="comment">//[r] default = 1.0</span></div><div class="line">}</div></div><!-- fragment --><ul>
<li>operator: name of operator; see list below</li>
<li>options: list any operator-specific options (most will be blank)<ul>
<li><em>see below</em></li>
</ul>
</li>
<li>printBoth: Print &lt;a|h|b&gt; and &lt;b|h|a&gt; ? false by default. (For <em>some</em> operators, e.g., involving derivatives, this is a good test of numerical error. For most operators, values will be trivially the same; reduced matrix elements, sign may be different.)</li>
<li>onlyDiagonal: If true, will only print diagonal MEs &lt;a|h|a&gt;</li>
<li>radialIntegral: if true, calculates the radial integral (definition depends on specific operator)</li>
<li>rpa: Include RPA (core polarisation) corrections to MEs, using TDHF method</li>
<li>rpa_diagram: Include RPA (core polarisation), using diagram (Goldstone) technique</li>
<li>omega: frequency for solving TDHF/RPA equations, should be positive. Put "omega=each;" to solve at the frequency for each transition (i.e., re-solve TDHF for each transition).</li>
<li>A_vertex, b_vertex: Effective QED vertex func: A * alpha * exp(-b * r / alpha)</li>
</ul>
<h3>Available operators:</h3>
<p>Here I list the available operators, and their possible options. Remember; the program will print out the full list of available options if you ask it to.</p>
<div class="fragment"><div class="line"><span class="keyword">operator</span> = E1; <span class="comment">//Electric dipole operator:</span></div><div class="line">options = [</div><div class="line">  gauge; <span class="comment">//[t] lform, vform. default = lform</span></div><div class="line">];</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">operator</span> = Ek; <span class="comment">//Electric multipole operator:</span></div><div class="line">options = [</div><div class="line">  k; <span class="comment">//[i] default = 1</span></div><div class="line">];</div></div><!-- fragment --><ul>
<li>k=1 =&gt; E1, dipole. k=2 =&gt; E2, quadrupole etc.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">operator</span> = r; <span class="comment">//scalar r</span></div><div class="line">options = [</div><div class="line">  power; <span class="comment">//[r] default = 1. Will calc &lt;|r^n|&gt;.</span></div><div class="line">];</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">operator</span> = pnc; <span class="comment">// spin-independent (Qw) PNC operator.</span></div><div class="line">options = [</div><div class="line">  <a class="code" href="namespacePhysConst.html#af3948ef083a64b0a3ff75aa6e8ddf8e9">c</a>; <span class="comment">//[r] half-density radius. By default, uses rrms from Z,A [see nucleus]</span></div><div class="line">  t; <span class="comment">//[r] skin thickness. default = 2.3</span></div><div class="line">];</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">operator</span> = Hrad_el; <span class="comment">// QED electric part (Euhling+electric SE)</span></div></div><!-- fragment --><ul>
<li>Takes similar arguments as RadPot (except for scale_l and core_qed)<ul>
<li>Simple, Ueh, SE_h, SE_l, rcut, scale_rN (but not SE_mag)</li>
</ul>
</li>
<li>Including RPA should be equivalent to including QED into core <a class="el" href="namespaceHF.html" title="Functions and classes for Hartree-Fock. ">HF</a> equations<ul>
<li>Note: only rpa_diagram method seems to work</li>
</ul>
</li>
<li>Typically used with onlyDiagonal=true, and radialIntegral=true (get energy shifts)</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">operator</span> = Hrad_mag; <span class="comment">// QED magnetic part (magnetic SE form-factor)</span></div></div><!-- fragment --><ul>
<li>QED magnetic part (magnetic SE form-factor)</li>
<li>Takes similar arguments as RadPot (except for scale_l and core_qed)<ul>
<li>SE_mag, rcut, scale_rN (but not Simple, Ueh, SE_h, SE_l,)</li>
</ul>
</li>
<li>Including RPA should be equivalent to including QED into core <a class="el" href="namespaceHF.html" title="Functions and classes for Hartree-Fock. ">HF</a> equations<ul>
<li>Note: only rpa_diagram method seems to work</li>
</ul>
</li>
<li>Typically used with onlyDiagonal=true, and radialIntegral=true (get energy shifts)</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">operator</span> = hfs; <span class="comment">// Magnetic dipole hyperfine structure constant A</span></div><div class="line">options = [</div><div class="line">  mu;     <span class="comment">//[r] Nuc. mag. moment. Will be looked up by default</span></div><div class="line">  I;      <span class="comment">//[r] Nuc. spin. Will be looked up by default</span></div><div class="line">  rrms;   <span class="comment">//[r] Nuc. rms radius. Will be looked up by default</span></div><div class="line">  F(r);   <span class="comment">//[t] Bohr-Weisskopf function. ball, shell, pointlike, VolotkaBW, doublyOddBW</span></div><div class="line">  printF; <span class="comment">//[b] default = false. Will write F(r)/r^2 to text file</span></div><div class="line">  <span class="comment">// -----</span></div><div class="line">  <span class="comment">// the following are only used for &quot;VolotkaBW/doublyOddBW&quot;</span></div><div class="line">  <span class="comment">// both are optional (will be deduced otherwise)</span></div><div class="line">  <a class="code" href="namespaceAngular.html#ac327cb94806f4a1d1167953cb7f73476">parity</a>; <span class="comment">//[i] parity of unpaired valence nucleon (+1/-1)</span></div><div class="line">  gl;     <span class="comment">//[i] =1 for valence proton, =0 for valence neutron</span></div><div class="line">  <span class="comment">// -----</span></div><div class="line">  <span class="comment">// The following are only read in if F(r) = doublyOddBW,</span></div><div class="line">  <span class="comment">// but are _required_ in that case (current values are for 212-Fr)</span></div><div class="line">  mu1 = 4.00; <span class="comment">//see paper for explanation</span></div><div class="line">  I1 = 4.5;</div><div class="line">  l1 = 5.;</div><div class="line">  gl1 = 1;</div><div class="line">  I2 = 0.5;</div><div class="line">  l2 = 1.;</div><div class="line">];</div></div><!-- fragment --><h3>Other Modules:</h3>
<ul>
<li>Note: 'Modules' documentation also available in the doxygen (html) documentation on github; that is likely more up-to-date <hr/>
 <div class="fragment"><div class="line"><a class="code" href="namespaceModule_1_1Tests.html">Module::Tests</a> {</div><div class="line">  orthonormal;     <span class="comment">//[b] Prints worst &lt;a|b&gt;&#39;s. default = true</span></div><div class="line">  orthonormal_all; <span class="comment">//[b] Print all &lt;a|b&gt;&#39;s. default = false</span></div><div class="line">  Hamiltonian;     <span class="comment">//[b] check eigenvalues of Hamiltonian. default = false</span></div><div class="line">  boundaries;      <span class="comment">//[b] check f(rmax)/fmax. default = false</span></div><div class="line">  basisTests;        <span class="comment">//[b] Tests basis by evaluating sum rules + HFS/Energies</span></div><div class="line">}</div></div><!-- fragment --></li>
</ul>
<p>Various tests of numerical errors: </p><hr/>
 <div class="fragment"><div class="line">Module::pnc{ <a class="code" href="namespacePhysConst.html#af3948ef083a64b0a3ff75aa6e8ddf8e9">c</a>; t; transition; rpa; omega; nmain; }</div></div><!-- fragment --><p> Uses both 'solving equations' (TDHF) and sum-over-states methods. For solving equations, calculates both:</p><ul>
<li>&lt;yA_w|d| B&gt; + &lt;A |d|xB_w&gt;</li>
<li>&lt;A |w|XB_d&gt; + &lt;YA_d|w| B&gt;</li>
<li>Does not (yet) include DCP</li>
</ul>
<p>c, t: half-density radius and skin-thickness (in fm) for rho(r). Will look up default values by default.</p><ul>
<li>transition: For E1_PNC a-&gt;b transition.<ul>
<li>in form "a,b", uses the 'short' notation:</li>
<li>e.g., "6s+,7s+" for 6s_1/2 -&gt; 7s_1/2</li>
<li>e.g., "6s+,5d-" for 6s_1/2 -&gt; 5d_3/2</li>
</ul>
</li>
<li>rpa: true/false. Include RPA or not (TDHF ,method)</li>
<li>omega: frequency used for RPA (default is transition frequency of valence).</li>
<li>nmain: highest n (prin. q. number) considered as part of 'main'.<ul>
<li>If not given, will be max(n_core)+4</li>
<li>(Calculation broken into core, main, tail) <hr/>
 <div class="fragment"><div class="line"><a class="code" href="namespaceModule.html#ae558aaf746d7d202a25f2d2ad2471bb3">Module::polarisability</a>{ rpa; omega; transition; omega_max; omega_steps;  }</div></div><!-- fragment --></li>
</ul>
</li>
</ul>
<p>Calculate dipole polarisabilitities (static, dynamic, alpha, vector beta)</p><ul>
<li>Uses both 'solving equations' (TDHF) and sum-over-states methods.<ul>
<li>rpa: true/false. Include RPA or not (TDHF ,method)</li>
<li>omega: frequency used for alpha_0 (dipole polarisability). default is 0.</li>
<li>transition: For scalar/vector a-&gt;b transition polarisability.<ul>
<li>in form "a,b", e.g., "6s+,7s+" for 6s_1/2 -&gt; 7s_1/2</li>
</ul>
</li>
<li>omega_max: maximum frequency for dynamic polarisability. Default is 0.<ul>
<li>nb: only runs dynamic pol. if omega_max&gt;0</li>
</ul>
</li>
<li>omega_steps: Number of steps used for dynamic. default = 30. (linear scale)</li>
</ul>
</li>
</ul>
<p>Note: transition polarisabilities written for s-states only. They might be correct for other states too, but NOT checked. Especially for beta, pretty sure it's wrong for non-s states. </p><hr/>
 <div class="fragment"><div class="line"><a class="code" href="namespaceModule.html#ab9e0f86215b16adbb90b371dcae5bb52">Module::structureRad</a>{</div><div class="line">  <span class="keyword">operator</span>; options; rpa; printBoth; onlyDiagonal; omega; n_minmax;  </div><div class="line">}</div></div><!-- fragment --><ul>
<li>Calculates Structure Radiation + Normalisation of States</li>
<li>Note: Most input options are similar to matrixElements module:</li>
<li>n_minmax: is input as list of ints:<ul>
<li>n_minmax = min,max;</li>
<li>min: minimum n for core states kept in summations</li>
<li>max: maximum n for excited states kept in summations</li>
</ul>
</li>
<li>For explanation of the rest, see matrixElements module. <hr/>
 <div class="fragment"><div class="line">Module::lifetimes{</div><div class="line">  E1;   <span class="comment">//[b] Include E1 transitions. default = true</span></div><div class="line">  E1;   <span class="comment">//[b] Include E2 transitions. default = false</span></div><div class="line">}</div></div><!-- fragment --> Calculates lifetimes of valence states. Note: uses <a class="el" href="namespaceHF.html" title="Functions and classes for Hartree-Fock. ">HF</a> energies (prints all data to screen) <hr/>
 <div class="fragment"><div class="line"><a class="code" href="namespaceModule.html#a81711048d92da3f4f84ffbb58f9f04df">Module::HFAnomaly</a> {</div><div class="line">  Alist;  <span class="comment">//[i,i,...] // Which A&#39;s to calculate for (blank for all)</span></div><div class="line"> <span class="comment">// ~ most inputs same as operator = hfs</span></div><div class="line">}</div></div><!-- fragment --> Calculates the hyperfine anomaly (and BW effect) for all available odd isotopes of given atom, relative to the 'main' isotope (see Atom).</li>
<li>Note: Only runs for odd isotopes; to get anomaly for even isotopes, use am even isotope as reference (For doubly-odd Bohr-Weisskopf input options, see operator = hfs)</li>
<li>Takes same input as operator = hfs, except for F(r), since it runs for each F(r) <hr/>
 <div class="fragment"><div class="line">Module::BohrWeisskopf { <span class="comment">//Calculates BW effect for Ball/Single-particle</span></div><div class="line">  <span class="comment">// Takes same input at operator = hfs</span></div><div class="line">  <span class="comment">// Except for F(r), since it runs for each F(r)</span></div><div class="line">}</div></div><!-- fragment --> <hr/>
 <div class="fragment"><div class="line">Module::WriteOrbitals { <span class="comment">//writes orbitals to textfile:</span></div><div class="line">    label = outputLabel; <span class="comment">//[t] Optional. blank by default</span></div><div class="line">}</div></div><!-- fragment --> Writes the core + valence orbitals (+ the total electron density) to a file, in GNUplot friendly format. The (optional) label will be appended to the output file name. Plot file using GNUPLOT. For example, try this:</li>
</ul>
<p><em>plot for [i=2:20] "file.txt" u 1:i every :::0::0 w l t columnheader(i)</em></p><ul>
<li><em>plot for [i=2:20] "file.txt" u 1:i every :::1::1 w l t columnheader(i)</em></li>
<li><em>plot "file.txt" u 1:2 every :::2::2 w l t "Core Density"</em> <hr/>
 <div class="fragment"><div class="line"><a class="code" href="namespaceModule_1_1FitParametric.html">Module::FitParametric</a> {</div><div class="line">  method = Green;     <span class="comment">//[t] Green, Tietz</span></div><div class="line">  statesToFit = core; <span class="comment">//[t] core, valence, both</span></div><div class="line">  fitWorst;           <span class="comment">//[b] false (default), true;</span></div><div class="line">}</div></div><!-- fragment --> Performs a 2D fit to determine the best-fit values for the given two-parameter parametric potential (Green, or Tietz potentials), returns H/g d/t parameters for the best-fit. Does fit to Hartree-Fock energies. Will either do for core or valence states, or both (works best for one or the other). fitWorst: if true, will optimise fit for the worst state. If false, uses least squares for the fit. False is default <hr/>
</li>
</ul>
<div class="fragment"><div class="line">Module::AtomicKernal {</div><div class="line">    <span class="comment">// Some typical inputs. All are required.</span></div><div class="line">  Emin = 0.01; <span class="comment">// in keV</span></div><div class="line">  Emax = 4.0;</div><div class="line">  Esteps = 25;</div><div class="line">  qmin = 0.001; <span class="comment">// in MeV</span></div><div class="line">  qmax = 4.0;</div><div class="line">  qsteps = 100;</div><div class="line">  max_l_bound = 1; <span class="comment">// l for bound states</span></div><div class="line">  max_L = 2;       <span class="comment">// L is multipolarity</span></div><div class="line">  output_text = <span class="keyword">true</span>;</div><div class="line">  output_binary = <span class="keyword">true</span>;</div><div class="line">  label = test_new;</div><div class="line">  use_plane_waves = <span class="keyword">false</span>;</div><div class="line">}</div></div><!-- fragment --><p> Calculates the "Atomic Kernal" (for scattering/ionisation) for each core orbital, as a function of momentum transfer (q), and energy deposition (dE). Writes result to human-readable (and gnuplot-friendly) file, and/or binary.</p><ul>
<li>For definitions/details, see:<ul>
<li>B.M. Roberts, V.V. Flambaum <a href="https://link.aps.org/doi/10.1103/PhysRevD.100.063017" title="pay-walled">Phys.Rev.D 100, 063017 (2019)</a>; <a href="https://arxiv.org/abs/1904.07127" title="free download">arXiv:1904.07127</a>.</li>
<li>B.M.Roberts, V.A.Dzuba, V.V.Flambaum, M.Pospelov, Y.V.Stadnik, <a href="https://link.aps.org/doi/10.1103/PhysRevD.93.115037" title="pay-walled">Phys.Rev.D 93, 115037 (2016)</a>; <a href="https://arxiv.org/abs/1604.04559" title="free download">arXiv:1604.04559</a>.</li>
</ul>
</li>
<li>Note: need quite a dense grid [large number of points] for<ul>
<li>a) highly oscillating J_L function at low r, and</li>
<li>b) to solve equation for high-energy continuum states.</li>
</ul>
</li>
<li>Sums over 'all' continuum angular momentum states (and multipolarities)<ul>
<li>Maximum values for l are input parameters Binary output from this program is read in by dmeXSection program Note: tested only for neutral atoms (V^N potential). Also: tested mainly for high values of q </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
