<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ampsci: qip Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ampsci
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">qip Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Collection of handy tools.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqip_1_1StrongType.html">StrongType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A light-weight easy-to-use single-file header-only template class for strong typing.  <a href="structqip_1_1StrongType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afc0507d5136eb258e060a7a6a83ded5a"><td class="memTemplParams" colspan="2"><a id="afc0507d5136eb258e060a7a6a83ded5a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afc0507d5136eb258e060a7a6a83ded5a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#afc0507d5136eb258e060a7a6a83ded5a">check_value</a> (std::ostream *ostr, const std::string_view &amp;name, const T value, const T expected, const T tollerance)</td></tr>
<tr class="memdesc:afc0507d5136eb258e060a7a6a83ded5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if value==expected, within +/-tollerance. Writes report to ostr. <br /></td></tr>
<tr class="separator:afc0507d5136eb258e060a7a6a83ded5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69f6f34c9b6441ca1c403d6777f0af9"><td class="memTemplParams" colspan="2"><a id="ac69f6f34c9b6441ca1c403d6777f0af9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac69f6f34c9b6441ca1c403d6777f0af9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ac69f6f34c9b6441ca1c403d6777f0af9">check_value</a> (const std::string_view &amp;name, const T value, const T expected, const T tollerance)</td></tr>
<tr class="memdesc:ac69f6f34c9b6441ca1c403d6777f0af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload which prints to cout <br /></td></tr>
<tr class="separator:ac69f6f34c9b6441ca1c403d6777f0af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95825e5328321b8e0f83c230a42bd384"><td class="memItemLeft" align="right" valign="top"><a id="a95825e5328321b8e0f83c230a42bd384"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a95825e5328321b8e0f83c230a42bd384">fstring</a> (const std::string format,...)</td></tr>
<tr class="memdesc:a95825e5328321b8e0f83c230a42bd384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a formatted std::string, with formatting printf-like commands. Note: maximum string lenth is 80 characters. If longer string required, use provided overload. <br /></td></tr>
<tr class="separator:a95825e5328321b8e0f83c230a42bd384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f77c0373bce44b37d7e26af0f03de4"><td class="memItemLeft" align="right" valign="top"><a id="a97f77c0373bce44b37d7e26af0f03de4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a97f77c0373bce44b37d7e26af0f03de4">fstring</a> (const std::size_t size, const std::string format,...)</td></tr>
<tr class="memdesc:a97f77c0373bce44b37d7e26af0f03de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload: size is maximum string length (buffer size). <br /></td></tr>
<tr class="separator:a97f77c0373bce44b37d7e26af0f03de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b99af2e2e2a1d9438a995c2555f51e"><td class="memTemplParams" colspan="2"><a id="a80b99af2e2e2a1d9438a995c2555f51e"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a80b99af2e2e2a1d9438a995c2555f51e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max_abs</b> (T first, Args... rest)</td></tr>
<tr class="separator:a80b99af2e2e2a1d9438a995c2555f51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2670fff7c6536bb13a8d677336e72fb"><td class="memTemplParams" colspan="2"><a id="ac2670fff7c6536bb13a8d677336e72fb"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ac2670fff7c6536bb13a8d677336e72fb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min_abs</b> (T first, Args... rest)</td></tr>
<tr class="separator:ac2670fff7c6536bb13a8d677336e72fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa8ce8b7b2ea7201cf954b9c52cc2dd"><td class="memTemplParams" colspan="2"><a id="a2fa8ce8b7b2ea7201cf954b9c52cc2dd"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a2fa8ce8b7b2ea7201cf954b9c52cc2dd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (T first, Args... rest)</td></tr>
<tr class="separator:a2fa8ce8b7b2ea7201cf954b9c52cc2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e81dfdf0cd840d0ead840f72a066be"><td class="memTemplParams" colspan="2"><a id="aa9e81dfdf0cd840d0ead840f72a066be"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:aa9e81dfdf0cd840d0ead840f72a066be"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (T first, Args... rest)</td></tr>
<tr class="separator:aa9e81dfdf0cd840d0ead840f72a066be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe1bfb56638d7c8dccdff2d6b8f07ad"><td class="memTemplParams" colspan="2"><a id="a1fe1bfb56638d7c8dccdff2d6b8f07ad"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a1fe1bfb56638d7c8dccdff2d6b8f07ad"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max_difference</b> (T first, Args... rest)</td></tr>
<tr class="separator:a1fe1bfb56638d7c8dccdff2d6b8f07ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93902898009ff74b7ff28f72ba7bcf2"><td class="memTemplParams" colspan="2"><a id="ae93902898009ff74b7ff28f72ba7bcf2"></a>
template&lt;int n, typename T &gt; </td></tr>
<tr class="memitem:ae93902898009ff74b7ff28f72ba7bcf2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ae93902898009ff74b7ff28f72ba7bcf2">pow</a> (T x)</td></tr>
<tr class="memdesc:ae93902898009ff74b7ff28f72ba7bcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">x^n for integer n (n compile-time template parameter) <br /></td></tr>
<tr class="separator:ae93902898009ff74b7ff28f72ba7bcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5f2fdede884dd745ce55f2da0f5d7d"><td class="memTemplParams" colspan="2"><a id="a9d5f2fdede884dd745ce55f2da0f5d7d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d5f2fdede884dd745ce55f2da0f5d7d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a9d5f2fdede884dd745ce55f2da0f5d7d">pow</a> (T x, int n)</td></tr>
<tr class="memdesc:a9d5f2fdede884dd745ce55f2da0f5d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">x^n for integer n (runtime n) <br /></td></tr>
<tr class="separator:a9d5f2fdede884dd745ce55f2da0f5d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762e6d5bf39ffca404e2d778fafbb0d9"><td class="memTemplParams" colspan="2"><a id="a762e6d5bf39ffca404e2d778fafbb0d9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a762e6d5bf39ffca404e2d778fafbb0d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a762e6d5bf39ffca404e2d778fafbb0d9">sign</a> (T value)</td></tr>
<tr class="memdesc:a762e6d5bf39ffca404e2d778fafbb0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sign of value. <br /></td></tr>
<tr class="separator:a762e6d5bf39ffca404e2d778fafbb0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af091ad44ba19b2538888cf9487af0e31"><td class="memTemplParams" colspan="2"><a id="af091ad44ba19b2538888cf9487af0e31"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af091ad44ba19b2538888cf9487af0e31"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#af091ad44ba19b2538888cf9487af0e31">clip</a> (T value, T max_abs)</td></tr>
<tr class="memdesc:af091ad44ba19b2538888cf9487af0e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clips value to between -max &lt;= value &lt;= max clip(x,max) : |x| &gt; max, ret max; if |x|&lt;-max, -max; else x. <br /></td></tr>
<tr class="separator:af091ad44ba19b2538888cf9487af0e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62de3c5b336d174e02feabf709867f3"><td class="memTemplParams" colspan="2"><a id="ab62de3c5b336d174e02feabf709867f3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab62de3c5b336d174e02feabf709867f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ab62de3c5b336d174e02feabf709867f3">chop</a> (T value, T min_abs)</td></tr>
<tr class="memdesc:ab62de3c5b336d174e02feabf709867f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets values |v|&lt;min to zero; if |v|&gt;=min, returns v. <br /></td></tr>
<tr class="separator:ab62de3c5b336d174e02feabf709867f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2feca8ceeedd078122dc9bac30a7d6"><td class="memTemplParams" colspan="2"><a id="aca2feca8ceeedd078122dc9bac30a7d6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca2feca8ceeedd078122dc9bac30a7d6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#aca2feca8ceeedd078122dc9bac30a7d6">compare</a> (const std::vector&lt; T &gt; &amp;first, const std::vector&lt; T &gt; &amp;second)</td></tr>
<tr class="memdesc:aca2feca8ceeedd078122dc9bac30a7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly compare two arithmetic vectors of the same type and length. Returns pair {delta, itr} where delta = |max|{first - second}, itr is iterator to position in first vector where the maximum delta occured. Note: Maximum is by magnitude, but delta is signed as (first-second) <br /></td></tr>
<tr class="separator:aca2feca8ceeedd078122dc9bac30a7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c41c906c90e34a8f2770b69ab2b486c"><td class="memTemplParams" colspan="2"><a id="a4c41c906c90e34a8f2770b69ab2b486c"></a>
template&lt;typename T , typename U , typename Func &gt; </td></tr>
<tr class="memitem:a4c41c906c90e34a8f2770b69ab2b486c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a4c41c906c90e34a8f2770b69ab2b486c">compare</a> (const std::vector&lt; T &gt; &amp;first, const std::vector&lt; U &gt; &amp;second, Func &amp;func)</td></tr>
<tr class="memdesc:a4c41c906c90e34a8f2770b69ab2b486c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two vectors of the same length, according to the rule given by func. Returns pair {delta, itr} where delta = max{|func(first,second)|}, itr is iterator to position in first vector where the maximum delta occured. Note: Maximum is by magnitude. <br /></td></tr>
<tr class="separator:a4c41c906c90e34a8f2770b69ab2b486c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1250da0bd75d06567ef62d2b3fe349de"><td class="memTemplParams" colspan="2"><a id="a1250da0bd75d06567ef62d2b3fe349de"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1250da0bd75d06567ef62d2b3fe349de"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a1250da0bd75d06567ef62d2b3fe349de">compare_eps</a> (const std::vector&lt; T &gt; &amp;first, const std::vector&lt; T &gt; &amp;second)</td></tr>
<tr class="memdesc:a1250da0bd75d06567ef62d2b3fe349de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares values of two arithmetic vectors of the same type and length, relative to second value. Returns pair {eps, itr} where eps = |max|{(first - second)/second}, itr is iterator to position in first vector where the maximum eps occured. Note: Maximum is by magnitude, but eps is signed as (first-second)/second. <br /></td></tr>
<tr class="separator:a1250da0bd75d06567ef62d2b3fe349de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e81190dc8ffc9511654919606192e0"><td class="memTemplParams" colspan="2"><a id="a10e81190dc8ffc9511654919606192e0"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a10e81190dc8ffc9511654919606192e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a10e81190dc8ffc9511654919606192e0">add</a> (std::vector&lt; T &gt; *first, const std::vector&lt; T &gt; &amp;second, const Args &amp;... rest)</td></tr>
<tr class="memdesc:a10e81190dc8ffc9511654919606192e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds any number of vectors, in place (modifies first vector). Must be of same type. May allocate; will resize first to be size of largest vector. <br /></td></tr>
<tr class="separator:a10e81190dc8ffc9511654919606192e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e3c005369dc0c6d29a7dd70db14a50"><td class="memTemplParams" colspan="2"><a id="a92e3c005369dc0c6d29a7dd70db14a50"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a92e3c005369dc0c6d29a7dd70db14a50"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a92e3c005369dc0c6d29a7dd70db14a50">add</a> (std::vector&lt; T &gt; first, const std::vector&lt; T &gt; &amp;second, const Args &amp;... rest)</td></tr>
<tr class="memdesc:a92e3c005369dc0c6d29a7dd70db14a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds any number of vectors. Must be of same type. Size of returned vector will be size of largest vector; may allocate more than once if vectors are not all of same size. <br /></td></tr>
<tr class="separator:a92e3c005369dc0c6d29a7dd70db14a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5c9297990be46cfa7daefb02fd6bf2"><td class="memTemplParams" colspan="2"><a id="aed5c9297990be46cfa7daefb02fd6bf2"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:aed5c9297990be46cfa7daefb02fd6bf2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#aed5c9297990be46cfa7daefb02fd6bf2">multiply</a> (std::vector&lt; T &gt; *first, const std::vector&lt; T &gt; &amp;second, const Args &amp;... rest)</td></tr>
<tr class="memdesc:aed5c9297990be46cfa7daefb02fd6bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies any number of (arithmetic) vectors, in place (modifies first vector). Must be of same type. May allocate; will resize first to be size of largest vector. <br /></td></tr>
<tr class="separator:aed5c9297990be46cfa7daefb02fd6bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e080a9adf7d8c250a96e7524228f0ea"><td class="memTemplParams" colspan="2"><a id="a0e080a9adf7d8c250a96e7524228f0ea"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a0e080a9adf7d8c250a96e7524228f0ea"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a0e080a9adf7d8c250a96e7524228f0ea">multiply</a> (std::vector&lt; T &gt; first, const std::vector&lt; T &gt; &amp;second, const Args &amp;... rest)</td></tr>
<tr class="memdesc:a0e080a9adf7d8c250a96e7524228f0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies any number of vectors. Must be of same type. Size of returned vector will be size of largest vector; may allocate more than once if vectors are not all of same size. <br /></td></tr>
<tr class="separator:a0e080a9adf7d8c250a96e7524228f0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dae14ed4a0cefbb92dccfa981a3a580"><td class="memTemplParams" colspan="2"><a id="a2dae14ed4a0cefbb92dccfa981a3a580"></a>
template&lt;typename F , typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a2dae14ed4a0cefbb92dccfa981a3a580"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a2dae14ed4a0cefbb92dccfa981a3a580">compose</a> (const F &amp;func, std::vector&lt; T &gt; *first, const std::vector&lt; T &gt; &amp;second, const Args &amp;... rest)</td></tr>
<tr class="memdesc:a2dae14ed4a0cefbb92dccfa981a3a580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes any number of vectors, in place (modifies first vector), using the provided function. Must be of same type. May allocate; will resize first to be size of largest vector. e.g., <a class="el" href="namespaceqip.html#a2dae14ed4a0cefbb92dccfa981a3a580" title="Composes any number of vectors, in place (modifies first vector), using the provided function...">qip::compose</a>(std::plus{}, &amp;vo, v2, v3); same as qip::add(&amp;vo, v2, v3) <br /></td></tr>
<tr class="separator:a2dae14ed4a0cefbb92dccfa981a3a580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110b3c854b606a59bce0898f52af0417"><td class="memTemplParams" colspan="2"><a id="a110b3c854b606a59bce0898f52af0417"></a>
template&lt;typename F , typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a110b3c854b606a59bce0898f52af0417"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a110b3c854b606a59bce0898f52af0417">compose</a> (const F &amp;func, std::vector&lt; T &gt; first, const std::vector&lt; T &gt; &amp;second, const Args &amp;... rest)</td></tr>
<tr class="memdesc:a110b3c854b606a59bce0898f52af0417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes any number of vectors. Must be of same type. Size of returned vector will be size of largest vector; may allocate more than once if vectors are not all of same size. <br /></td></tr>
<tr class="separator:a110b3c854b606a59bce0898f52af0417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1419dc459f6c79c3271ce4c7608292a6"><td class="memTemplParams" colspan="2"><a id="a1419dc459f6c79c3271ce4c7608292a6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1419dc459f6c79c3271ce4c7608292a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a1419dc459f6c79c3271ce4c7608292a6">scale</a> (std::vector&lt; T &gt; *vec, T x)</td></tr>
<tr class="memdesc:a1419dc459f6c79c3271ce4c7608292a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place scalar multiplication of std::vector - types must match. <br /></td></tr>
<tr class="separator:a1419dc459f6c79c3271ce4c7608292a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b64ac3915ed88109c23ef7a011a5a7"><td class="memTemplParams" colspan="2"><a id="a97b64ac3915ed88109c23ef7a011a5a7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97b64ac3915ed88109c23ef7a011a5a7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a97b64ac3915ed88109c23ef7a011a5a7">scale</a> (std::vector&lt; T &gt; vec, T x)</td></tr>
<tr class="memdesc:a97b64ac3915ed88109c23ef7a011a5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication of std::vector - types must match. <br /></td></tr>
<tr class="separator:a97b64ac3915ed88109c23ef7a011a5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4090db55ea9f6ddb8049de78eef37a0f"><td class="memTemplParams" colspan="2"><a id="a4090db55ea9f6ddb8049de78eef37a0f"></a>
template&lt;typename T , typename N &gt; </td></tr>
<tr class="memitem:a4090db55ea9f6ddb8049de78eef37a0f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a4090db55ea9f6ddb8049de78eef37a0f">uniform_range</a> (T first, T last, N number)</td></tr>
<tr class="memdesc:a4090db55ea9f6ddb8049de78eef37a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a uniformly*(see below) distributed range of values between [first,last] with number steps. number must be at least 2. first+last are guarenteed to be the first and last points in the range. For integral T, range will not be perfectly uniform, due to [first, ..., last] guarentee and rounding; also in this case same value may appear more than once if too-many steps are requested. <br /></td></tr>
<tr class="separator:a4090db55ea9f6ddb8049de78eef37a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40451d413829b19aab5a69909f69ade"><td class="memTemplParams" colspan="2"><a id="ae40451d413829b19aab5a69909f69ade"></a>
template&lt;typename T , typename N &gt; </td></tr>
<tr class="memitem:ae40451d413829b19aab5a69909f69ade"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ae40451d413829b19aab5a69909f69ade">logarithmic_range</a> (T first, T last, N number)</td></tr>
<tr class="memdesc:ae40451d413829b19aab5a69909f69ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a logarithmicly*(see below) distributed range of values between [first,last] with number steps. number must be at least 2. first+last are guarenteed to be the first and last points in the range. For integral T, range will not be perfectly logarithmic, due to [first, ..., last] guarentee and rounding; also in this case same value may appear more than once if too-many steps are requested. <br /></td></tr>
<tr class="separator:ae40451d413829b19aab5a69909f69ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09964aedde8dc411a1a358e6fe92cd73"><td class="memTemplParams" colspan="2"><a id="a09964aedde8dc411a1a358e6fe92cd73"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a09964aedde8dc411a1a358e6fe92cd73"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a09964aedde8dc411a1a358e6fe92cd73">multiply_at</a> (std::size_t i, const T &amp;first, const Args &amp;... rest)</td></tr>
<tr class="memdesc:a09964aedde8dc411a1a358e6fe92cd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">first[i]*...rest[i] &ndash; used to allow inner_product <br /></td></tr>
<tr class="separator:a09964aedde8dc411a1a358e6fe92cd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d591bea7748e9bdaec07966859e1f73"><td class="memTemplParams" colspan="2"><a id="a6d591bea7748e9bdaec07966859e1f73"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a6d591bea7748e9bdaec07966859e1f73"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a6d591bea7748e9bdaec07966859e1f73">inner_product</a> (const T &amp;first, const Args &amp;... rest)</td></tr>
<tr class="memdesc:a6d591bea7748e9bdaec07966859e1f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic inner product (v1,v2,...vn) : sum_i v1[i]*v2[i]*...vn[i]. <br /></td></tr>
<tr class="separator:a6d591bea7748e9bdaec07966859e1f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb07ffc75eec1e6c159f5bde1dfb19c4"><td class="memTemplParams" colspan="2"><a id="acb07ffc75eec1e6c159f5bde1dfb19c4"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:acb07ffc75eec1e6c159f5bde1dfb19c4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inner_product_sub</b> (std::size_t p0, std::size_t pinf, const T &amp;first, const Args &amp;... rest)</td></tr>
<tr class="separator:acb07ffc75eec1e6c159f5bde1dfb19c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625393770774da4553b27cbb967cf9c9"><td class="memTemplParams" colspan="2"><a id="a625393770774da4553b27cbb967cf9c9"></a>
template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:a625393770774da4553b27cbb967cf9c9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_to</b> (const F &amp;func, T list)</td></tr>
<tr class="separator:a625393770774da4553b27cbb967cf9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa640ffc8bf8b9952dd57ac5a34e7eb0e"><td class="memItemLeft" align="right" valign="top"><a id="aa640ffc8bf8b9952dd57ac5a34e7eb0e"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>comp_abs</b> = [](auto a, auto b) { return std::abs(a) &lt; std::abs(b); }</td></tr>
<tr class="separator:aa640ffc8bf8b9952dd57ac5a34e7eb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Collection of handy tools. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
